// RMQ Algorithms//Given N, then N numbers data set. Then in input given M and M orders, they can be “+ L X” - means add to L position X, “- L X” means take from L position X, and “? L R” find sum between L and R position.#include<stdio.h>int n,z = 1,tree[1001],R,L,ans,m,value1,value2,i;char c;void RMQ (int R, int L);void update(int pos);int main () {        scanf("%d",&n);    while (n > z) {        z *= 2;    }    for (i = z; i<=z+n-1 ; i++) {        scanf("%d", &tree[i]);    }    scanf("%d",&m);        for (i = z-1 ; i >= 1; i--) {        tree[i] = tree[2*i] + tree[2*i+1];    }    for (int i = 0; i <= m; i++){                scanf("%c%d%d", &c, &L , &R);        if (c == '+'){                    tree[L + z - 1] += R; //adding            update(L + z - 1);        }else if (c == '-'){                            tree[L + z - 1] -= R; // substacting            update(L + z - 1);                }else{                            RMQ(L + z - 1, R + z - 1); // sum between L and R            printf("%d\n", ans);        }    }    }void RMQ (int L, int R) {        ans = 0 ;    while (L <= R) {        if (L % 2 == 1) {            ans += tree[L];        }if (R % 2 == 0) {            ans += tree[R];        }        L = (L+1)/2;        R = (R-1)/2;    }    }void update(int pos){        for (int j = pos / 2; pos >= 1; j /= 2)        tree[j] = tree[j * 2] + tree[j * 2 + 1];    }